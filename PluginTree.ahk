#Requires AutoHotkey v2.0
#SingleInstance Force
;; |||TODO|||
    ;;-||Document|| How to use the "Ghost-AHK project" system.
    ;;-||Refactor|| 
        ;;+ |FileSafeDelete| Move to lib. (also in Build.ahk)

    ;;-||Maybe?||
        ;;?-|New-Args| Add flags to allow specifying things like when to make a "_submods.ahk" (instead of only--and alwyas--doing so at the top level), and maybe to select alternative file extensions to include.
        ;;?-|Refactor|
            ;;?+ Compartmentalize: Structure to polute the global namespace less. Either with classes or nested functions.

GenPluginTree(PluginDir, MakeSubmods := true, Manifest := "") {
  Manifest := GetManifestName(PluginDir, Manifest)
  
  OldDir := A_WorkingDir
  SetWorkingDir PluginDir
  {
    contents := ""
    Loop Files, "*.ahk" {
      If SubStr(A_LoopFileName, 1, 1) != "_" {
        if A_LoopFilePath != Manifest
          contents .= "#include " . A_LoopFilePath "`n"
      }
    }

    subMods := ""
    Loop Files, "*", "D" {
      If SubStr(A_LoopFileName, 1, 1) != "_" {
        minifest := GenPluginTree(A_LoopFilePath, false)
        subMods .= "  #include " . minifest "`n"
      }
    }
  } SetWorkingDir OldDir

  if subMods != "" {
    if MakeSubmods {
      WriteAutoGen(PluginDir, "_submods.ahk", subMods)
    }
    contents := "  `;SUBMODULES`n" . subMods . "  `;SUBMODULES`n`n" . contents
  }
  WriteAutoGen(PluginDir, Manifest, contents)
  return  PluginDir . "\" . Manifest
}

WriteAutoGen(Dir, FileName, Contents) {
  FilePath := Dir "\" . FileName
  Write(Str) {
    FileAppend Str, FilePath
  }
  FileSafeDelete(FilePath) ; make room to populate the file
  Write "; THIS FILE WAS AUTO-GENERATED BY 'PluginTree.ahk'.`n"
  Write "  `; MANUAL CHANGES MAY BE OVERWRITTEN `n`n"
  Write "#Requires AutoHotkey v2.0`n`n"
  Write contents
  Write "`n#HotIf"
}

GetManifestName(Dir, FileName := "") {
  if not FileName {
    SplitPath(Dir, &FileName)
    FileName := StrLower(FileName) ".ahk"
  }
  return "_" . FileName
}

; Also Should be in a library...
FileSafeDelete(FilePath) {
  if FileExist(FilePath) {
    FileDelete FilePath
  }
}