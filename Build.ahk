#Requires AutoHotkey v2.0
#SingleInstance Force
;; |||TODO|||
    ;;-||Document|| How to use the "Ghost-AHK project" system.
    ;;-||Refactor|| 
        ;;+ |FileSafeDelete| Move to lib. (also in PluginTree.ahk)

    ;;-||Maybe?||
        ;;?-|Refactor|
            ;;?+ Compartmentalize: Structure to polute the global namespace less. Either with classes or nested functions.
        ;;?-|New-Args| Add flags to expand customizability. Possibilities include wether to run the compiled version

        ;;?-|Expand-Src Mode| Long-Description
        /** Add arg to generate a single-file 'flattened'/'expanded' version of the source code. A sort of "compiling without compiling". Both because it is neat, and to allow better debugging by allowing you to see the exact code the interpreter does.  
            - Would need to match real AHK behavior, at any include copy pasting the code being pointed to at that line, but only if the specified file has not yet been included.
            - Would Probably recursively (and top down) handle each inclue. Scanning the main file for any includes, replacing all with the code they point to, repeat until a scan finds none. 
                + For each include in the sub file would need to append any directory info from the top level include. (i.e. if you include _plugins, and in there it includes 'Games\_games.ahk',  then if '_games.ahk' has the line '#include Tis.ahk' the include pasted into the main file would need to be changed to 'Games\Tis.ahk'.)
            - Maybe also stripping comments? but probably not.
            - Possibly as a seperate script that this one calls, but probably just a flag here.
            - possibly call the flag "debug", "src", or "expand".
        */
        ;;???- Use custom unique file exts for certain things:
            ;???+| autogenerated files | (".gahk"/".gak"?)
            ;???+|    '.m.ahk' files   | (".mahk"). Instead of 'faking' it with the double extension.

DEF_SCRIPT := "ahkAutorun.ahk" ; name AND extension of the script if no arg.
DEF_ICON := "AHK" ; name of the icon if no arg.

if A_Args.Length > 3  {
    MsgBox "Usage: AhkCompile.ahk [SourcePath] [IconName]? [CompilerPath]?"
    ExitApp
}

; Set all Params to either empty or passed args
SrcPath := ""
IconName := ""
CompPath := ""
if A_Args.Length > 0 {
    SrcPath := A_Args[1]
    if A_Args.Length >1 {
        IconName := A_Args[2] 
        if A_Args.Length >2  {
            CompPath := A_Args[3] 
        }
    }
}

; Set Default Compiler Path if not passed.
if not CompPath {
    CompPath := RegRead("HKLM\SOFTWARE\AutoHotkey", "InstallDir") "\Compiler\Ahk2Exe.exe"
}

; Set File Path to default if not passed (DEFSCRIPT in script DIR)
if not SrcPath {
    SrcPath := JoinPath(A_ScriptDir, DEF_SCRIPT)
}

; Get Script Name and Dir
SplitPath(SrcPath,, &ScriptDir,, &ScriptName)

; Set Icon to Script.ico if not passed.
if not IconName {
    IconName := ScriptName
    ;IconName := DEFICON
}

; Build Paths
OutputPath := JoinPath(ScriptDir, ScriptName, ".exe")
IconPath := JoinPath(ScriptDir, IconName, ".ico")
MahkPath := JoinPath(ScriptDir, ScriptName, ".m.ahk")

; Run the script's Mahk if it has one.
if FileExist(MahkPath) {
    RunWait MahkPath
}

; Kill and remove previous ver (Compiler get's mad if old file exists)
While ProcessExist(ScriptName . ".exe")
    ProcessClose ScriptName . ".exe"
FileSafeDelete(OutputPath)

; Build the Compiler Arguments. Including setting icon to Script.ico or DEFICON.ico or nothing.
CompArgs :=
    " /in " . SrcPath .
    " /out " . OutputPath
if FileExist(IconPath) {
    CompArgs .= " /icon " . IconPath
} else if (DEF_ICON != "") {
    IconPath := JoinPath(ScriptDir, DEF_ICON, ".ico")
    if FileExist(IconPath) {
        CompArgs .= " /icon " . IconPath
    }
}

; Compile
RunWait CompPath CompArgs
; RUN
Run OutputPath


; Should be a lib.
JoinPath(Base, Paths*) {

    if Instr(Base, "/") {
        sep := "/"
    } else {
        sep := "\"
    }

    for Path in Paths {
        if (Path == "") {
            continue
        }

        firstPChar := SubStr(Path, 1, 1)
        lastBChar := SubStr(Base, -1)
        if (firstPChar == ".") {
            Base .= Path
            continue
        }

        if (firstPChar == "\" or firstPChar == "/") {
            Path := SubStr(Path, 2)
        }
        if (lastBChar == "\" or lastBChar == "/") {
            Path := SubStr(Path, 1,-1)
        }

        Base .= sep . Path
    }
    return Base
}

; Should be a lib.
FileSafeDelete(FilePath) {
    if FileExist(FilePath) {
        FileDelete FilePath
    }
}